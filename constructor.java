// Constyructor 
// it is a special type of method which is getting excuted at the time of object creation .
class C1 {
    C1() {
        System.out.println("heyy");
    }

    public static void main(String[] args) {
        C1 t1 = new C1(); // heyy
    }
}

// rules :---
class Test1 {
    Test1() {
        System.out.println("constructor");
    }

    public static void main(String[] args) {
        Test1 t1 = new Test1();
    }
}
// without any return type we can call a constructor & it excuted at the time of
// object creation .

class Test2 {
    void Test2() {
        System.out.println("constructor"); // blank space
    }

    public static void main(String[] args) {
        Test2 t1 = new Test2();
    }
}
// When we give the return type to the constructor , it become a method & at the
// time of object creation , no-method is being excuted Therefore ...

class Test3 {
    void Test3() {
        System.out.println("constructor"); // blank space
    }

    public static void main(String[] args) {
        Test3 t1 = new Test3();
        t1.Test3();
    }
}
// When we give the return statement to a constructor it become method & it
// excuted after method calling

class Test4 {
    Test4() {
        System.out.println("constructor");
    }

    void Test4() {
        System.out.println("method"); // blank space
    }

    public static void main(String[] args) {
        Test4 t1 = new Test4(); // constructor
        t1.Test4(); // method
    }
}
// In the case within a class one constructor & a method is present . At the
// time of object creation "constructor" called and at the time of method
// calling "method " is caalled ..

// rule -2
// All the acess modifier are allowed for the constructor , but non -acess
// modifier are not allowed
class Test5 {
    public Test5() {
        System.out.println("constructor");
    }

    public static void main(String[] args) {
        Test5 t1 = new Test5();
    }
}

class Test6 {
    private Test6() {
        System.out.println("constructor");
    }

    public static void main(String[] args) {
        Test6 t1 = new Test6();
    }
}

class Test7 {
    Test7() {
        System.out.println("constructor");
    }

    public static void main(String[] args) {
        Test7 t1 = new Test7();
    }
}

class Test8 {
    private Test8() {
        System.out.println("constructor");
    }

    public static void main(String[] args) {
        Test8 t1 = new Test8();
    }
}

// Default constructor :-
// it is a special type of constructor which is automatically generated by
// compiler when there is no user friendly constructor present inside the
// constructor .

// I) there is only one statemenyt present inside the default con structor ie call to super (Super(); )
// ii)The default constructor always be non parameterized type .

// constructor overloading :-
// creating multiple type of constructor with same constructor name and
// different type of argument is known as constructor overloaading .
class Test9 {
    Test9(int x) {
        System.out.println("abc");
    }

    Test9(String s) {
        System.out.println("def");
    }

    public static void main(String[] args) {
        Test9 t1 = new Test9(10);
        Test9 t2 = new Test9("ccc");

    }
}

// constructor chaining :-
// this ()
// it is used to call the present class constructor .
class Test10 {
    Test10(int x) {
        this("non");
        System.out.println("abc");
    }

    Test10(String S) {
        System.out.println("def");
    }

    public static void main(String[] args) {
        Test10 t1 = new Test10(10);
    }
}

// ex-2
class Test11 {
    Test11(int x) {

        System.out.println("abc");
    }

    Test11(String S) {
        this(10);
        System.out.println("def");
    }

    public static void main(String[] args) {
        Test11 t1 = new Test11("zzz");
    }
}

// super ()
// it is used to call the parent class constructor
class Demo {
    Demo() {

        System.out.println("parent");
    }
}

class Test extends Demo {
    Test() {
        super();
        System.out.println("child");
    }

    public static void main(String[] args) {
        Test t1 = new Test();
    }
}


// rules to using constructor caller :--
// 1. if we want to use this()  & super()  inside any constructor  then we must have to write as the first statement inside the constructor .

// class Test12{
//     Test12(){
//         this();
//         System.out.println("abc");
//     }
//     public static void main(String[] args) {
//         Test12 t1=new Test12();
//     }
// }


//2.we can not use both this() & super() inside any constructor 

//3. If we are not provinding any constructor caller inside a constructor & by defaultly super() as its 1st statement .

class Test12 {
Test12(){
    System.out.println("Parent");
}
}

class Test13 extends Test12 {
    Test13() {
        System.out.println("child");
    }

    public static void main(String[] args) {
        Test13 t1=new Test13();
    }
}


//4. when there is no userdefined constructor then there is a default constructor present & inside that super() is present .

class Test14 {
    Test14(){
        System.out.println("abc");
    }
}
class Test15 extends Test14 {
    public static void main(String[] args) {
        Test15 t1 =new Test15();
    }
} 